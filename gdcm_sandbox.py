import gdcm
import pydicom
from pydicom.compat import in_py2
from pydicom.pixeldata import gdcm_numpy_pixel_format_typemap, construct_gdcm_image_from_dataset, reshape_pixel_array, \
    construct_numpy_dtype
import numpy as np
import matplotlib.pyplot as plt

test_file = r"C:\\Development\\Projects\\pydicom\\tests\\test_files\\CT_small.dcm"


def get_pixel_array(gdcm_image, ds):
    # get decompressed pixel array
    pixel_bytearray = gdcm_image.GetBuffer()
    if not in_py2:
        # the GDCM wrappers are generated by SWIG, which - under Python 3 - decodes all returned C++ char * pointers
        # as UTF-8 unicode strings with the surrogateescape error handler, so we can get the original bytearray
        # by encoding with the same parameters
        pixel_bytearray = pixel_bytearray.encode("utf-8", "surrogateescape")

    # determine the correct numpy datatype
    gdcm_pixel_format = gdcm_image.GetPixelFormat().GetScalarType()
    numpy_dtype = gdcm_numpy_pixel_format_typemap[gdcm_pixel_format]

    # if GDCM indicates that a byte swap is in order, make sure to inform numpy as well
    if gdcm_image.GetNeedByteSwap():
        numpy_dtype.newbyteorder('S')

    # finally, actually grab the bytearray through numpy
    # we use fromstring to copy the memory, so that all the GDCM variables can be garbage-collected
    pixel_array = np.fromstring(pixel_bytearray, dtype=numpy_dtype)

    # finally, reshape to match the image dimensions
    pixel_array = reshape_pixel_array(ds, pixel_array)

    return pixel_array


ds = pydicom.read_file(test_file)
gdcm_image = construct_gdcm_image_from_dataset(ds)
pixels = get_pixel_array(gdcm_image, ds)

reader = gdcm.ImageReader()
reader.SetFileName(test_file)
reader.Read()
gdcm_image_2 = reader.GetImage()
pixels_2 = get_pixel_array(gdcm_image_2, ds)

buffer = gdcm_image.GetBuffer()
buffer_2 = gdcm_image_2.GetBuffer()

fig, (ax1, ax2) = plt.subplots(1, 2)
ax1.imshow(pixels)
ax2.imshow(pixels_2)
fig.show()

print("wait")